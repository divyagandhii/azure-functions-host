using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

namespace Microsoft.Azure.WebJobs.Script.Metrics
{
    public static class IFunctionContainerActivityExtensions
    {
        private const double GBSecConversionFactor = 1024000.0;
        private const int FunctionsRuntimeMemoryOverhead = 100;
        internal const int BillingEventsBufferTimeInSeconds = 25;
        internal const int MinimumExecutionTimespan = 100;
        private const int MaxStaleFunctionActivities = 250000;
        internal const string TimeFormatForLogging = "HH:mm:ss.fff";

        public static double GetFunctionGbSecs(this IFunctionContainerActivity functionContainerActivity)
        {
            return functionContainerActivity.FunctionExecutionUnits / GBSecConversionFactor;
        }

        /// <summary>
        /// Calculate units for the next memory snapshot only.
        /// </summary>
        /// <returns>True if units were calculated.</returns>
        public static bool CalculateNextFunctionExecutionUnits(this IFunctionContainerActivity functionContainerActivity, IAnalyticsPublisher analyticsPublisher, bool buffer = true)
        {
            bool result = false;

            if (functionContainerActivity.MemorySnapshots != null &&
                functionContainerActivity.MemorySnapshots.Count > 0)
            {
                // get the next unprocessed memory snapshot and calculate units for it
                var nextMemoryBucketSnapshotTime = functionContainerActivity.MemorySnapshots.Keys[0];
                if (!buffer || nextMemoryBucketSnapshotTime.AddSeconds(BillingEventsBufferTimeInSeconds) < DateTime.UtcNow)
                {
                    var startTime = functionContainerActivity.LastFunctionExecutionCalcuationMemorySnapshotTime;
                    var endTime = nextMemoryBucketSnapshotTime;
                    functionContainerActivity.CalculateFunctionExecutionUnits(
                        startTime,
                        endTime,
                        FunctionsRuntimeMemoryOverhead,
                        analyticsPublisher);

                    functionContainerActivity.LastFunctionExecutionCalcuationMemorySnapshotTime = nextMemoryBucketSnapshotTime;
                    result = true;
                }
            }

            return result;
        }

        /// <summary>
        /// This function calculates function execution units based on memory consumption and concurrency. Start time and End time are based on
        /// memory snapshot metering service receives via an ETW event generated by DWAS. Imagine the following scenario:
        /// F1 t =1 -|-|-|-| | t = 7 (Memory 500 MB)
        /// F2 t =1  | |-|-|-| t = 7 (Memory 500 MB)
        /// We have two function running between t = 1 ms to t = 7 ms. Memory utilization at t = 7 ms was 500 MB. Imagine runtime memory 
        /// overhead is 100 MB. Each | represents 1 ms boundary and each - represents active function execution. In order to calculate GbSec 
        /// for this duration, we will calculate concurrency at every ms interval, divide that value with total memory utilization to 
        /// calculate the effective memory bucket size. Once we know the memory bucket size, we will multiply it with time to get MbMs value.
        /// at t = 2, we have one active fuction so effective Memory bucket = Round up to the nearest 128 multiple (500/1 - 100) = 512. MbMs = 512 x 1 = 512 MbMs
        /// at t =3, we have two active functions so effective Memory bucket = Round up to the nearest 128 multiple (500/2 - 100) = 256. MbMs = 256 x 2 = 512 MbMs
        /// and so on.
        /// From implementation perspective, instead of traversing through each millisecond, we find out all function invocation junctions where
        /// concurrency changes and use these junctions for MbMs calculations for efficiency.
        /// </summary>
        /// <param name="startTime">Start time</param>
        /// <param name="endTime">End time</param>
        /// <param name="functionsRuntimeMemoryOverhead">Memory taken by the runtime</param>
        public static void CalculateFunctionExecutionUnits(this IFunctionContainerActivity functionContainerActivity, DateTime startTime, DateTime endTime, int functionsRuntimeMemoryOverhead, IAnalyticsPublisher analyticsPublisher)
        {
            var memorySnapshot = functionContainerActivity.MemorySnapshots[endTime];

            // Calculate units for any currently active function executions
            if (functionContainerActivity.ActiveFunctionActivities != null)
            {
                var activeFunctions = functionContainerActivity.ActiveFunctionActivities.Values.Where(f => f.StartTime < endTime && f.EndTime > startTime);
                var functionInvocationSliceCount = activeFunctions.Count();
                if (functionInvocationSliceCount > 0)
                {
                    var functionInvocationsSlice = new Dictionary<string, FunctionInvocationSlice>(functionInvocationSliceCount);

                    // Let's find all active functions in this window.
                    foreach (var functionInvocationSlice in activeFunctions)
                    {
                        functionInvocationsSlice.Add(
                            functionInvocationSlice.InvocationId,
                            new FunctionInvocationSlice(
                                Max(Utility.TrimSubMilliseconds(functionInvocationSlice.StartTime), startTime),
                                Min(functionInvocationSlice.EndTime, endTime)));
                    }

                    var minStartTime = functionInvocationsSlice.Values.Select(s => s.StartTime).Min();
                    var effectiveStartTime = Max(minStartTime, startTime);

                    // Let's create all function invocation points. For every function invocation, this means start time and end time.
                    var functionExecutionPoints = new List<FunctionInvocationPoint>(functionInvocationSliceCount * 2);
                    foreach (var functionInvocationSlice in functionInvocationsSlice)
                    {
                        functionExecutionPoints.Add(new FunctionInvocationPoint(true, GetRelativeIndex(effectiveStartTime, functionInvocationSlice.Value.StartTime), functionInvocationSlice.Key));
                        functionExecutionPoints.Add(new FunctionInvocationPoint(false, GetRelativeIndex(effectiveStartTime, functionInvocationSlice.Value.EndTime), functionInvocationSlice.Key));
                    }

                    // Let's sort execution points so that we can visit them in ascending order.
                    functionExecutionPoints.Sort((x, y) => x.TimeOffset.CompareTo(y.TimeOffset));
                    int curIndex = 0;
                    var functionInvocationJunctions = new SortedList<int, FunctionInvocationJunction>(functionExecutionPoints.Count);
                    FunctionInvocationJunction previousFunctionInvocationJunction = null;
                    while (curIndex < functionExecutionPoints.Count)
                    {
                        var currentFunctionInvocationJunction = new FunctionInvocationJunction();

                        if (previousFunctionInvocationJunction != null)
                        {
                            foreach (var runningFunction in previousFunctionInvocationJunction.RunningFunctions)
                            {
                                // All functions that were previously running are still running unless there is an explicit change
                                currentFunctionInvocationJunction.RunningFunctions.Add(runningFunction);
                            }
                        }

                        int curOffset = functionExecutionPoints[curIndex].TimeOffset;
                        while (curIndex < functionExecutionPoints.Count && functionExecutionPoints[curIndex].TimeOffset == curOffset)
                        {
                            var invocationId = functionExecutionPoints[curIndex].InvocationId;
                            if (functionExecutionPoints[curIndex].IsStart)
                            {
                                if (!currentFunctionInvocationJunction.RunningFunctions.Contains(invocationId))
                                {
                                    currentFunctionInvocationJunction.RunningFunctions.Add(invocationId);
                                }
                            }
                            else
                            {
                                if (currentFunctionInvocationJunction.RunningFunctions.Contains(invocationId))
                                {
                                    currentFunctionInvocationJunction.RunningFunctions.Remove(invocationId);
                                }
                            }
                            ++curIndex;
                        }

                        functionInvocationJunctions.Add(curOffset, currentFunctionInvocationJunction);
                        previousFunctionInvocationJunction = currentFunctionInvocationJunction;
                    }

                    // Let's calculate MB-ms
                    if (functionInvocationJunctions.Count > 1)
                    {
                        const int memoryBucketStepSize = 128;

                        var previousJunctionTimeOffset = functionInvocationJunctions.Keys[0];
                        previousFunctionInvocationJunction = functionInvocationJunctions.Values[0];

                        for (int currentIndex = 1; currentIndex < functionInvocationJunctions.Count; currentIndex++)
                        {
                            var currentJunctionTimeOffset = functionInvocationJunctions.Keys[currentIndex];
                            var currentFunctionInvocationJunction = functionInvocationJunctions.Values[currentIndex];
                            var previousConcurrency = previousFunctionInvocationJunction.Concurrency;

                            if (previousConcurrency > 0)
                            {
                                var actualMemoryBucket = ((memorySnapshot - functionsRuntimeMemoryOverhead) / previousConcurrency);
                                int roundedMemoryBucket;
                                if (actualMemoryBucket <= memoryBucketStepSize)
                                {
                                    roundedMemoryBucket = memoryBucketStepSize;
                                }
                                else
                                {
                                    // Rounding it up to the nearest memory bucket size
                                    roundedMemoryBucket = (((int)((actualMemoryBucket + memoryBucketStepSize - 1) / memoryBucketStepSize)) * memoryBucketStepSize);
                                }

                                var functionExecutionTime = currentJunctionTimeOffset - previousJunctionTimeOffset;
                                var functionExecutionUnitPerFunction = ((long)functionExecutionTime) * ((long)roundedMemoryBucket);
                                functionContainerActivity.FunctionExecutionUnits += (functionExecutionUnitPerFunction * ((long)previousConcurrency));

                                foreach (var runningFunction in previousFunctionInvocationJunction.RunningFunctions)
                                {
                                    functionInvocationsSlice[runningFunction].IncrementExecutionUnitsAndTimeSlice(functionExecutionUnitPerFunction, functionExecutionTime);
                                }

                                functionContainerActivity.LastMemoryBucketSize = roundedMemoryBucket;
                            }

                            previousJunctionTimeOffset = currentJunctionTimeOffset;
                            previousFunctionInvocationJunction = currentFunctionInvocationJunction;
                        }

                        foreach (var functionInvocationSlice in functionInvocationsSlice)
                        {
                            functionContainerActivity.ActiveFunctionActivities[functionInvocationSlice.Key].DynamicMemoryBucketCalculations.Add(new DynamicMemoryBucketCalculation
                            {
                                MemorySnapshotStartTime = startTime,
                                MemorySnapshotEndTime = endTime,
                                FunctionSliceStartTime = functionInvocationSlice.Value.StartTime,
                                FunctionSliceEndTime = functionInvocationSlice.Value.EndTime,
                                FunctionTimeSlice = functionInvocationSlice.Value.FunctionTimeSlice,
                                FunctionExecutionUnits = functionInvocationSlice.Value.FunctionExecutionUnits,
                                TotalMemory = memorySnapshot
                            });
                        }
                    }
                }

                // remove function invocations that are completed
                var finishedFunctionActivities = functionContainerActivity.ActiveFunctionActivities.Values.Where(f => f.CurrentExecutionStage == FunctionExecutionStage.Finished && f.EndTime < endTime).ToArray();
                foreach (var functionActivity in finishedFunctionActivities)
                {
                    RaiseAnalyticsEvent(functionActivity, functionContainerActivity.SiteName, functionContainerActivity.FunctionContainerSizeInMb, "InvocationFinished", analyticsPublisher);
                    functionContainerActivity.ActiveFunctionActivities.Remove(functionActivity.InvocationId);
                }
            }

            // Remove this memory snapshot since it's not needed anymore.
            // Every time we calculate units for a memory snapshot, we include
            // any in progress function executions and accumulate those units to the
            // activity.
            functionContainerActivity.MemorySnapshots.Remove(endTime);
        }

        public static void RemoveStaleFunctionExecutions(this IFunctionContainerActivity functionContainerActivity, IAnalyticsPublisher analyticsEventGenerator)
        {
            if (functionContainerActivity.ActiveFunctionActivities != null)
            {
                var runningFunctionsToRemove = new List<IFunctionActivity>();
                foreach (var runningFunctionInstance in functionContainerActivity.ActiveFunctionActivities.Values)
                {
                    if (runningFunctionInstance.LastUpdatedTimeUtc.Add(TimeSpan.FromMinutes(10)) < DateTime.UtcNow)
                    {
                        analyticsEventGenerator.WriteError(
                                runningFunctionInstance.ProcessId,
                                functionContainerActivity.SiteName,
                                string.Format("Removing idle function activity even though it's not in Finished State yet. Details: {0}",
                                    runningFunctionInstance.FormatFunctionDetails()),
                                string.Empty);

                        runningFunctionsToRemove.Add(runningFunctionInstance);
                    }
                }

                foreach (var runningFunctionToRemove in runningFunctionsToRemove)
                {
                    MeterAndEvictFunctionInvocation(functionContainerActivity, analyticsEventGenerator, runningFunctionToRemove, "OrphanedInvocation");
                }
            }
        }

        public static void UpdateMemorySnapshotList(this IFunctionContainerActivity functionContainerActivity, long memoryConsumptionBytes, DateTime snapshotTime, IAnalyticsPublisher analyticsPublisher, int bufferSeconds = BillingEventsBufferTimeInSeconds)
        {
            if (memoryConsumptionBytes > 0 && functionContainerActivity.FunctionContainerSizeInMb > 0)
            {
                var timestamp = Utility.TrimSubMilliseconds(snapshotTime);
                double memoryConsumptionInMb = ((double)memoryConsumptionBytes) / (1024 * 1024);
                if (functionContainerActivity.MemorySnapshots == null)
                {
                    functionContainerActivity.MemorySnapshots = new SortedList<DateTime, double>();
                }

                var currentLength = functionContainerActivity.MemorySnapshots.Count;
                if (currentLength <= 0
                    || functionContainerActivity.MemorySnapshots.Keys[currentLength - 1] < timestamp)
                {
                    functionContainerActivity.MemorySnapshots.Add(timestamp, memoryConsumptionInMb);
                }
                else
                {
                    // Let's add this memory snapshot if it's not too late & we can determine a potential conflict by looking at top n items.
                    bool? conflictFound = null;
                    if (DateTime.UtcNow < snapshotTime.AddSeconds(bufferSeconds - 5))
                    {
                        // Let's look at top 10 items to determine a potential conflict
                        for (var currentIndex = currentLength - 1; currentIndex >= 0 && (currentLength - currentIndex) < 10; currentIndex--)
                        {
                            if (functionContainerActivity.MemorySnapshots.Keys[currentIndex] == timestamp)
                            {
                                conflictFound = true;
                                break;
                            }
                            else if (functionContainerActivity.MemorySnapshots.Keys[currentIndex] < timestamp)
                            {
                                conflictFound = false;
                                break;
                            }
                        }

                        if (!conflictFound.GetValueOrDefault(true))
                        {
                            functionContainerActivity.MemorySnapshots.Add(timestamp, memoryConsumptionInMb);
                        }
                    }

                    if (conflictFound.GetValueOrDefault(true))
                    {
                        // This shouldn't happen. Let's log an error message.
                        int processId = functionContainerActivity.ActiveFunctionActivities?.Values.First().ProcessId ?? 0;
                        analyticsPublisher.WriteError(
                            processId,
                            functionContainerActivity.SiteName,
                            "Error in UpdateMemorySnapshotList",
                            string.Format("Could not add the memory snapshot as either it was was received too late or there is a conflict. Memory snapshot time:{0}, ConflictFound:{1}",
                                timestamp.ToString("yyyy-MM-dd HH:mm:ss.fff",
                                CultureInfo.InvariantCulture),
                                conflictFound.HasValue ? conflictFound.Value.ToString() : "NULL"));
                    }
                }
            }
        }

        public static void UpdateFunctionActivity(this IFunctionContainerActivity functionContainerActivity, IFunctionActivity functionActivityToAdd, IAnalyticsPublisher analyticsPublisher, DateTime? now = null)
        {
            now = now ?? DateTime.UtcNow;

            functionContainerActivity.LastFunctionUpdateTimeStamp = now.Value;
            var activity = (IFunctionActivity)functionActivityToAdd.Clone();
            activity.ActualExecutionTimeSpanInMs = activity.ExecutionTimeSpanInMs;
            activity.LastUpdatedTimeUtc = now.Value;

            if (activity.ExecutionTimeSpanInMs < MinimumExecutionTimespan)
            {
                activity.ExecutionTimeSpanInMs = MinimumExecutionTimespan;
            }

            if (functionContainerActivity.ActiveFunctionActivities == null)
            {
                functionContainerActivity.ActiveFunctionActivities = (IDictionary<string, IFunctionActivity>)new Dictionary<string, IFunctionActivity>();
            }

            if (functionActivityToAdd.CurrentExecutionStage == FunctionExecutionStage.Finished && functionContainerActivity.FunctionContainerSizeInMb > 0)
            {
                functionContainerActivity.FunctionExecutionCount++;
            }

            IFunctionActivity functionActivity = null;
            if (functionContainerActivity.ActiveFunctionActivities.TryGetValue(functionActivityToAdd.InvocationId, out functionActivity)
                && functionActivity != null)
            {
                // Let's adjust the current execution time
                if (activity.ExecutionTimeSpanInMs > functionActivity.ExecutionTimeSpanInMs)
                {
                    functionContainerActivity.FunctionExecutionTimeInMs += (activity.ExecutionTimeSpanInMs - functionActivity.ExecutionTimeSpanInMs);
                }

                functionActivity.CopyFrom(activity);
            }
            else
            {
                // This is the first time we are receiving a metering ETW event for this function activity
                functionActivity = activity;
                if (functionActivity.ExecutionTimeSpanInMs > 0)
                {
                    functionContainerActivity.FunctionExecutionTimeInMs += functionActivity.ExecutionTimeSpanInMs;
                }

                if (functionContainerActivity.ActiveFunctionActivities.Count > MaxStaleFunctionActivities)
                {
                    analyticsPublisher.WriteError(
                        functionActivityToAdd.ProcessId,
                        functionContainerActivity.SiteName,
                        string.Format("ActiveFunctionActivities unusually large number of elements. Current count: {0}", functionContainerActivity.ActiveFunctionActivities.Count),
                        string.Format("Current elements of ActiveFunctionActivities: {0}", functionContainerActivity.FormatActiveFunctionActivities()));

                    // Let's remove the least recently updated elements.
                    var elementsToRemove = functionContainerActivity.ActiveFunctionActivities.Values.OrderBy(f => f.LastUpdatedTimeUtc).Take(MaxStaleFunctionActivities / 2);
                    foreach (var elementToRemove in elementsToRemove)
                    {
                        MeterAndEvictFunctionInvocation(functionContainerActivity, analyticsPublisher, elementToRemove, "TooManyInvocations");
                    }
                }

                functionContainerActivity.ActiveFunctionActivities.Add(functionActivity.InvocationId, functionActivity);
            }
        }

        private static void MeterAndEvictFunctionInvocation(IFunctionContainerActivity functionContainerActivity, IAnalyticsPublisher analyticsEventGenerator, IFunctionActivity elementToRemove, string reason)
        {
            var functionTimeSlice = elementToRemove.ExecutionTimeSpanInMs - elementToRemove.GetTotalDynamicMemoryBilledTime();

            // Let's just use the last memory bucket for charging these functions before they are evicted
            if (functionTimeSlice > 0)
            {
                var memoryBucketSize = functionContainerActivity.LastMemoryBucketSize;
                if (memoryBucketSize <= 0)
                {
                    memoryBucketSize = functionContainerActivity.FunctionContainerSizeInMb;
                }
                var startTime = elementToRemove.StartTime > functionContainerActivity.LastFunctionExecutionCalcuationMemorySnapshotTime ? elementToRemove.StartTime : functionContainerActivity.LastFunctionExecutionCalcuationMemorySnapshotTime;

                var functionExecutionUnits = memoryBucketSize * functionTimeSlice;
                functionContainerActivity.FunctionExecutionUnits += functionExecutionUnits;
                functionContainerActivity.ActiveFunctionActivities[elementToRemove.InvocationId].DynamicMemoryBucketCalculations.Add(new DynamicMemoryBucketCalculation
                {
                    MemorySnapshotStartTime = startTime,
                    MemorySnapshotEndTime = startTime.AddMilliseconds(functionTimeSlice),
                    FunctionSliceStartTime = startTime,
                    FunctionSliceEndTime = startTime.AddMilliseconds(functionTimeSlice),
                    FunctionTimeSlice = functionTimeSlice,
                    FunctionExecutionUnits = functionExecutionUnits,
                    TotalMemory = memoryBucketSize
                });
            }

            RaiseAnalyticsEvent(elementToRemove, functionContainerActivity.SiteName, functionContainerActivity.FunctionContainerSizeInMb, reason, analyticsEventGenerator);
            functionContainerActivity.ActiveFunctionActivities.Remove(elementToRemove.InvocationId);
        }

        public static string FormatActiveFunctionActivities(this IFunctionContainerActivity functionContainerActivity)
        {
            var errorDetails = new StringBuilder();
            if (functionContainerActivity.ActiveFunctionActivities != null)
            {
                var functionOrderedView = functionContainerActivity.ActiveFunctionActivities.Values.OrderBy(f => f.LastUpdatedTimeUtc);
                var functionCount = 0;
                foreach (var activeFunctionActivity in functionOrderedView)
                {
                    errorDetails.Append(activeFunctionActivity.FormatFunctionDetails() + " ");
                    functionCount++;
                    if (functionCount > 100)
                    {
                        break;
                    }
                }
            }
            return errorDetails.ToString();
        }

        private static void RaiseAnalyticsEvent(IFunctionActivity functionActivity, string containerName, int functionContainerSizeInMb, string reason, IAnalyticsPublisher analyticsPublisher)
        {
            var totalDynamicMemoryBilledTime = functionActivity.GetTotalDynamicMemoryBilledTime();

            // Let's make sure that we have metered the whole execution timespan.
            if (functionActivity.ExecutionTimeSpanInMs != totalDynamicMemoryBilledTime)
            {
                analyticsPublisher.WriteError(
                        functionActivity.ProcessId,
                        containerName,
                        string.Format("ExecutionTimeSpanInMs does not match with TotalDynamicMemoryBilledTime"),
                        string.Format("InvocationId:{0} ExecutionId:{1} FunctionName:{2} ExecutionTimeSpanInMs:{3} TotalDynamicMemoryBilledTime:{4} FunctionExecutionUnits:{5} StartTime:{6}",
                            functionActivity.InvocationId,
                            functionActivity.ExecutionId,
                            functionActivity.FunctionName,
                            functionActivity.ExecutionTimeSpanInMs,
                            totalDynamicMemoryBilledTime,
                            functionActivity.GetFunctionExecutionUnits(),
                            functionActivity.StartTime.ToString(TimeFormatForLogging)));
            }

            analyticsPublisher.WriteEvent(
                containerName,
                "Functions",
                "ExecutionId",
                functionActivity.ExecutionId,
                "ExecutionTimeSpan,ExecutionCount,ActualExecutionTimeSpan,FunctionContainerSize,FunctionName,InvocationId,Concurrency,IsSucceeded,StartTime,TotalDynamicMemoryBucketBilledTime,FunctionExecutionUnits,Reason,DynamicMemoryBucketCalculations",
                string.Format("{0},1,{1},{2},{3},{4},{5},{6},{7},{8},{9},{10},{11}", functionActivity.ExecutionTimeSpanInMs, functionActivity.ActualExecutionTimeSpanInMs, functionContainerSizeInMb, functionActivity.FunctionName, functionActivity.InvocationId, functionActivity.Concurrency, functionActivity.IsSucceeded, functionActivity.StartTime.ToString(TimeFormatForLogging), totalDynamicMemoryBilledTime, functionActivity.GetFunctionExecutionUnits(), reason, functionActivity.SerializeDynamicMemoryBucketCalculations()),
                "FunctionMeterEmitted",
                functionActivity.LastUpdatedTimeUtc,
                functionActivity.CurrentExecutionStage == FunctionExecutionStage.Finished ? true : false);
        }

        // Returns different in timeStamp and startTime in milliseconds
        private static int GetRelativeIndex(DateTime startTime, DateTime timeStamp)
        {
            if (startTime > timeStamp)
            {
                throw new ArgumentException(string.Format("startTime:{0} timeStamp:{1}", startTime, timeStamp));
            }

            return (int)(timeStamp - startTime).TotalMilliseconds;
        }

        private static DateTime Max(DateTime date1, DateTime date2)
        {
            return date1 < date2 ? date2 : date1;
        }

        private static DateTime Min(DateTime date1, DateTime date2)
        {
            return date1 > date2 ? date2 : date1;
        }

        private class FunctionInvocationJunction
        {
            public HashSet<string> RunningFunctions { get; set; }

            public int Concurrency
            {
                get
                {
                    return RunningFunctions.Count;
                }
            }

            public FunctionInvocationJunction()
            {
                RunningFunctions = new HashSet<string>();
            }
        }

        private class FunctionInvocationPoint
        {
            public bool IsStart { get; set; }
            public int TimeOffset { get; set; }
            public string InvocationId { get; set; }

            public FunctionInvocationPoint(bool isStart, int timeOffset, string invocationId)
            {
                IsStart = isStart;
                TimeOffset = timeOffset;
                InvocationId = invocationId;
            }
        }

        private class FunctionInvocationSlice
        {
            public DateTime StartTime { get; set; }
            public DateTime EndTime { get; set; }
            public long FunctionExecutionUnits { get; set; }
            public long FunctionTimeSlice { get; set; }

            public FunctionInvocationSlice(DateTime startTime, DateTime endTime)
            {
                StartTime = startTime;
                EndTime = endTime;
                FunctionExecutionUnits = 0;
                FunctionTimeSlice = 0;
            }

            public void IncrementExecutionUnitsAndTimeSlice(long executionUnits, int timeSlice)
            {
                FunctionExecutionUnits += executionUnits;
                FunctionTimeSlice += timeSlice;
            }
        }
    }
}
